<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursion - DSA with Python</title>
    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <div class="logo"><h1>üìö DSA with Python</h1></div>
            <ul class="nav-menu">
                <li><a href="../../index.html">Home</a></li>
                <li class="dropdown">
                    <a href="#">Data Structures</a>
                    <div class="dropdown-content">
                        <a href="../data-structures/arrays.html">Arrays</a>
                        <a href="../data-structures/linked-lists.html">Linked Lists</a>
                        <a href="../data-structures/stacks.html">Stacks</a>
                        <a href="../data-structures/queues.html">Queues</a>
                        <a href="../data-structures/trees.html">Trees</a>
                        <a href="../data-structures/graphs.html">Graphs</a>
                        <a href="../data-structures/heaps.html">Heaps</a>
                        <a href="../data-structures/hash-tables.html">Hash Tables</a>
                    </div>
                </li>
                <li class="dropdown">
                    <a href="#">Algorithms</a>
                    <div class="dropdown-content">
                        <a href="sorting.html">Sorting Algorithms</a>
                        <a href="searching.html">Searching Algorithms</a>
                        <a href="dynamic-programming.html">Dynamic Programming</a>
                        <a href="recursion.html" class="active">Recursion</a>
                        <a href="graph-algorithms.html">Graph Algorithms</a>
                        <a href="greedy.html">Greedy Algorithms</a>
                    </div>
                </li>
                <li><a href="../complexity-analysis.html">Complexity Analysis</a></li>
                <li><a href="../resources.html">Resources</a></li>
            </ul>
            <div class="hamburger"><span></span><span></span><span></span></div>
        </div>
    </nav>

    <main class="content">
        <div class="page-container">
            <div class="breadcrumb"><a href="../../index.html">Home</a> / Algorithms / Recursion</div>
            <div class="page-header">
                <h1>Recursion</h1>
                <p>Function calling itself to solve problems by breaking them into smaller parts</p>
            </div>

            <div class="section">
                <h2>What is Recursion?</h2>
                <p>Recursion is a technique where a function calls itself to solve a problem by breaking it down into simpler instances of the same problem. Every recursive function must have a base case to stop the recursion.</p>
            </div>

            <div class="section">
                <h2>Components of Recursion</h2>
                <ul>
                    <li><strong>Base Case:</strong> Condition to stop recursion</li>
                    <li><strong>Recursive Case:</strong> Function calls itself with modified parameters</li>
                    <li><strong>Progress:</strong> Each call gets closer to base case</li>
                </ul>
            </div>

            <div class="section">
                <h2>Examples</h2>

                <h3>1. Factorial</h3>
                <div class="code-block">
                    <pre><code class="language-python">def factorial(n):
    """
    Calculate factorial of n.
    Time: O(n) | Space: O(n) - recursion stack
    """
    # Base case
    if n <= 1:
        return 1
    
    # Recursive case
    return n * factorial(n - 1)

# Test
print(factorial(5))  # Output: 120</code></pre>
                </div>

                <h3>2. Sum of Array Elements</h3>
                <div class="code-block">
                    <pre><code class="language-python">def sum_array(arr, n):
    """Sum all elements in array"""
    if n == 0:
        return 0
    
    return arr[n-1] + sum_array(arr, n - 1)

# Test
print(sum_array([1, 2, 3, 4, 5], 5))  # Output: 15</code></pre>
                </div>

                <h3>3. Binary Search Recursively</h3>
                <div class="code-block">
                    <pre><code class="language-python">def binary_search_recursive(arr, target, left, right):
    """Binary search using recursion"""
    if left > right:
        return -1
    
    mid = (left + right) // 2
    
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search_recursive(arr, target, mid + 1, right)
    else:
        return binary_search_recursive(arr, target, left, mid - 1)</code></pre>
                </div>

                <h3>4. Tree Traversal</h3>
                <div class="code-block">
                    <pre><code class="language-python">class TreeNode:
    def __init__(self, val=0):
        self.val = val
        self.left = None
        self.right = None

def inorder(node):
    """Inorder traversal: Left, Root, Right"""
    if not node:
        return
    
    inorder(node.left)
    print(node.val, end=" ")
    inorder(node.right)</code></pre>
                </div>
            </div>

            <div class="section">
                <h2>Recursion vs Iteration</h2>
                <div class="pros-cons">
                    <div class="pros">
                        <h4>‚úì Recursion Advantages</h4>
                        <ul>
                            <li>Cleaner code</li>
                            <li>Natural for tree/graph problems</li>
                            <li>Easier to understand logic</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚úó Recursion Disadvantages</h4>
                        <ul>
                            <li>Stack overflow risk</li>
                            <li>Slower than iteration</li>
                            <li>Extra memory usage</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>üéØ Understanding Recursion Visually</h2>
                <div class="code-block">
                    <pre><code class="language-text">Example: factorial(5)

Call Stack (builds up):
factorial(5)
  ‚îî‚îÄ 5 * factorial(4)
      ‚îî‚îÄ 4 * factorial(3)
          ‚îî‚îÄ 3 * factorial(2)
              ‚îî‚îÄ 2 * factorial(1)
                  ‚îî‚îÄ 1 (BASE CASE)

Return values (unwinding):
1 (base case)
2 * 1 = 2
3 * 2 = 6
4 * 6 = 24
5 * 24 = 120 (final result)

KEY: Each level of the call stack waits for 
     the deeper call to return!</code></pre>
                </div>
            </div>

            <div class="section">
                <h2>üí° Key Takeaways</h2>
                <div class="pros-cons">
                    <div class="pros">
                        <h4>Recursion Essentials:</h4>
                        <ul>
                            <li><strong>Base Case:</strong> MUST have one or infinite recursion</li>
                            <li><strong>Recursive Case:</strong> Must progress toward base case</li>
                            <li><strong>Stack Depth:</strong> Python default ~1000, can cause stack overflow</li>
                            <li><strong>Call Stack:</strong> Each call takes memory until resolved</li>
                            <li><strong>Tail Call:</strong> Some languages optimize this (Python doesn't)</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>Common Mistakes:</h4>
                        <ul>
                            <li>‚ùå Missing or wrong base case ‚Üí infinite recursion</li>
                            <li>‚ùå Not progressing toward base case</li>
                            <li>‚ùå Too deep recursion ‚Üí stack overflow</li>
                            <li>‚ùå Recalculating same values ‚Üí use memoization</li>
                            <li>‚ùå Choosing recursion when iteration is better</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>üöÄ Optimization: Memoization</h2>
                <div class="code-block">
                    <pre><code class="language-python"># Without memoization - SLOW for large n
def fib_slow(n):
    if n <= 1:
        return n
    return fib_slow(n-1) + fib_slow(n-2)  # Recalculates many times!

# Time: O(2^n) - exponential!
# fib(5) calls fib(4) and fib(3)
#   fib(4) calls fib(3) and fib(2)
#     fib(3) is calculated TWICE!

# With memoization - FAST by caching results
def fib_memo(n, memo=None):
    if memo is None:
        memo = {}
    
    if n in memo:
        return memo[n]  # Return cached result
    
    if n <= 1:
        return n
    
    # Calculate and store
    memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)
    return memo[n]

# Time: O(n) - linear!

# Or use Python decorator
from functools import lru_cache

@lru_cache(maxsize=None)
def fib_cached(n):
    if n <= 1:
        return n
    return fib_cached(n-1) + fib_cached(n-2)</code></pre>
                </div>
            </div>

            <div class="section">
                <h2>üéì When to Use Recursion</h2>
                <div class="code-block">
                    <pre><code class="language-text">‚úì USE RECURSION WHEN:
‚îú‚îÄ Problem has natural recursive structure
‚îÇ  ‚îî‚îÄ Trees, graphs, divide-and-conquer
‚îú‚îÄ Makes code much cleaner and clearer
‚îú‚îÄ Depth is limited (< 500)
‚îî‚îÄ You can use memoization for optimization

‚úó AVOID RECURSION WHEN:
‚îú‚îÄ Simple iteration works better
‚îú‚îÄ Deep recursion possible (stack overflow risk)
‚îú‚îÄ Performance critical and recursion slower
‚îî‚îÄ No clear recursive structure</code></pre>
                </div>
            </div>

            <div class="section">
                <h2>üìö Real-World Applications</h2>
                <ul>
                    <li><strong>File Systems:</strong> Traversing nested folders</li>
                    <li><strong>Compilers:</strong> Parsing expressions with nested structure</li>
                    <li><strong>Game AI:</strong> Minimax algorithm for decision trees</li>
                    <li><strong>Backtracking:</strong> N-Queens, sudoku solver, maze solving</li>
                    <li><strong>Database Queries:</strong> Hierarchical data (organizational structures)</li>
                    <li><strong>Dynamic Programming:</strong> Fibonacci, knapsack problems</li>
                </ul>
            </div>

            <div class="section">
                <h2>üîó Related Topics</h2>
                <ul>
                    <li><a href="dynamic-programming.html">Dynamic Programming</a> - Uses recursion + memoization</li>
                    <li><a href="../data-structures/trees.html">Trees</a> - Recursive traversal</li>
                    <li><a href="../data-structures/graphs.html">Graphs</a> - DFS uses recursion</li>
                    <li><a href="../complexity-analysis.html">Complexity Analysis</a> - Analyze recursive functions</li>
                </ul>
            </div>
        </div>
    </main>

    <footer class="footer">
        <div class="footer-content">
            <p>&copy; 2026 DSA with Python. Designed for students learning Data Structures and Algorithms.</p>
            <p>Created with ‚ù§Ô∏è for the programming community</p>
        </div>
    </footer>

    <script src="../../js/script.js"></script>
</body>
</html>
