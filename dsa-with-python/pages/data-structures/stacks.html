<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stacks - DSA with Python</title>
    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <div class="logo">
                <h1>üìö DSA with Python</h1>
            </div>
            <ul class="nav-menu">
                <li><a href="../../index.html">Home</a></li>
                <li class="dropdown">
                    <a href="#">Data Structures</a>
                    <div class="dropdown-content">
                        <a href="arrays.html">Arrays</a>
                        <a href="linked-lists.html">Linked Lists</a>
                        <a href="stacks.html" class="active">Stacks</a>
                        <a href="queues.html">Queues</a>
                        <a href="trees.html">Trees</a>
                        <a href="graphs.html">Graphs</a>
                        <a href="heaps.html">Heaps</a>
                        <a href="hash-tables.html">Hash Tables</a>
                    </div>
                </li>
                <li class="dropdown">
                    <a href="#">Algorithms</a>
                    <div class="dropdown-content">
                        <a href="../algorithms/sorting.html">Sorting Algorithms</a>
                        <a href="../algorithms/searching.html">Searching Algorithms</a>
                        <a href="../algorithms/dynamic-programming.html">Dynamic Programming</a>
                        <a href="../algorithms/recursion.html">Recursion</a>
                        <a href="../algorithms/graph-algorithms.html">Graph Algorithms</a>
                        <a href="../algorithms/greedy.html">Greedy Algorithms</a>
                    </div>
                </li>
                <li><a href="../complexity-analysis.html">Complexity Analysis</a></li>
                <li><a href="../resources.html">Resources</a></li>
            </ul>
            <div class="hamburger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
    </nav>

    <main class="content">
        <div class="page-container">
            <div class="breadcrumb">
                <a href="../../index.html">Home</a> / Data Structures / Stacks
            </div>

            <div class="page-header">
                <h1>Stacks</h1>
                <p>LIFO (Last-In-First-Out) data structure for managing elements</p>
            </div>

            <div class="section">
                <h2>What is a Stack?</h2>
                <p>A stack is a linear data structure that follows the <strong>Last-In-First-Out (LIFO)</strong> principle. Elements are added and removed from the same end called the <strong>top</strong>. Think of a stack of plates - you add and remove plates from the top.</p>
            </div>

            <div class="section">
                <h2>Key Concepts</h2>
                <ul>
                    <li><strong>Push:</strong> Add an element to the top</li>
                    <li><strong>Pop:</strong> Remove and return the top element</li>
                    <li><strong>Peek:</strong> View the top element without removing</li>
                    <li><strong>Empty:</strong> Check if stack is empty</li>
                    <li><strong>LIFO:</strong> Last element added is first to be removed</li>
                </ul>
            </div>

            <div class="section">
                <h2>Stack Implementation</h2>

                <h3>Using Python List</h3>
                <div class="code-block">
                    <pre><code class="language-python">class Stack:
    def __init__(self):
        self.items = []
    
    # Push element - O(1)
    def push(self, data):
        self.items.append(data)
    
    # Pop element - O(1)
    def pop(self):
        if not self.is_empty():
            return self.items.pop()
        return None
    
    # Peek top element - O(1)
    def peek(self):
        if not self.is_empty():
            return self.items[-1]
        return None
    
    # Check if empty - O(1)
    def is_empty(self):
        return len(self.items) == 0
    
    # Get size - O(1)
    def size(self):
        return len(self.items)
    
    # Display stack
    def display(self):
        print(self.items)</code></pre>
                </div>

                <h3>Usage Example</h3>
                <div class="code-block">
                    <pre><code class="language-python"># Create stack
stack = Stack()

# Push elements
stack.push(10)
stack.push(20)
stack.push(30)
stack.push(40)

# Display
print(stack.items)  # Output: [10, 20, 30, 40]

# Peek
print(stack.peek())  # Output: 40

# Pop
print(stack.pop())  # Output: 40
print(stack.pop())  # Output: 30

# Check size
print(stack.size())  # Output: 2</code></pre>
                </div>

                <h3>Using Linked List</h3>
                <div class="code-block">
                    <pre><code class="language-python">class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class StackLL:
    def __init__(self):
        self.head = None
    
    def push(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
    
    def pop(self):
        if not self.head:
            return None
        data = self.head.data
        self.head = self.head.next
        return data
    
    def peek(self):
        if not self.head:
            return None
        return self.head.data
    
    def is_empty(self):
        return self.head is None</code></pre>
                </div>
            </div>

            <div class="section">
                <h2>Complexity Analysis</h2>
                <div class="complexity-box">
                    <h4>Time Complexity:</h4>
                    <p><strong>Push:</strong> O(1) - Add to top</p>
                    <p><strong>Pop:</strong> O(1) - Remove from top</p>
                    <p><strong>Peek:</strong> O(1) - View top</p>
                    <p><strong>Search:</strong> O(n) - May need to check all elements</p>
                </div>
                <div class="complexity-box">
                    <h4>Space Complexity:</h4>
                    <p><strong>O(n)</strong> - Where n is number of elements</p>
                </div>
            </div>

            <div class="section">
                <h2>Applications</h2>
                <ul>
                    <li><strong>Function Call Stack:</strong> Managing recursive function calls</li>
                    <li><strong>Expression Evaluation:</strong> Evaluating postfix and infix expressions</li>
                    <li><strong>Undo/Redo:</strong> Implementing undo functionality in applications</li>
                    <li><strong>Backtracking:</strong> Solving maze and puzzle problems</li>
                    <li><strong>Browser History:</strong> Managing back button functionality</li>
                    <li><strong>Syntax Parsing:</strong> Matching brackets and parentheses</li>
                </ul>
            </div>

            <div class="section">
                <h2>Common Problems</h2>

                <h3>1. Valid Parentheses</h3>
                <div class="code-block">
                    <pre><code class="language-python">def is_valid_parentheses(s):
    """
    Check if parentheses are balanced.
    Time Complexity: O(n)
    Space Complexity: O(n)
    """
    stack = []
    pairs = {'(': ')', '{': '}', '[': ']'}
    
    for char in s:
        if char in pairs:
            stack.append(char)
        elif char in pairs.values():
            if not stack or pairs[stack.pop()] != char:
                return False
    
    return len(stack) == 0

# Test
print(is_valid_parentheses("({[]})"))  # Output: True
print(is_valid_parentheses("({[}])"))  # Output: False</code></pre>
                </div>

                <h3>2. Reverse String Using Stack</h3>
                <div class="code-block">
                    <pre><code class="language-python">def reverse_string(s):
    """
    Reverse a string using stack.
    Time Complexity: O(n)
    Space Complexity: O(n)
    """
    stack = Stack()
    
    for char in s:
        stack.push(char)
    
    reversed_str = ""
    while not stack.is_empty():
        reversed_str += stack.pop()
    
    return reversed_str

# Test
print(reverse_string("hello"))  # Output: "olleh"</code></pre>
                </div>

                <h3>3. Next Greater Element</h3>
                <div class="code-block">
                    <pre><code class="language-python">def next_greater_element(arr):
    """
    Find next greater element for each element.
    Time Complexity: O(n)
    Space Complexity: O(n)
    """
    result = [-1] * len(arr)
    stack = []
    
    for i in range(len(arr) - 1, -1, -1):
        while stack and stack[-1] <= arr[i]:
            stack.pop()
        
        if stack:
            result[i] = stack[-1]
        
        stack.append(arr[i])
    
    return result

# Test
print(next_greater_element([1, 5, 0, 3, 4, 5]))
# Output: [5, -1, 3, 4, 5, -1]</code></pre>
                </div>

                <h3>4. Implement MinStack</h3>
                <div class="code-block">
                    <pre><code class="language-python">class MinStack:
    """
    Stack that supports getMin() in O(1) time.
    """
    def __init__(self):
        self.stack = []
        self.min_stack = []
    
    def push(self, x):
        self.stack.append(x)
        if not self.min_stack or x <= self.min_stack[-1]:
            self.min_stack.append(x)
    
    def pop(self):
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()
    
    def top(self):
        return self.stack[-1]
    
    def get_min(self):
        return self.min_stack[-1]</code></pre>
                </div>
            </div>

            <div class="section">
                <h2>Advantages and Disadvantages</h2>
                <div class="pros-cons">
                    <div class="pros">
                        <h4>‚úì Advantages</h4>
                        <ul>
                            <li>Simple and efficient</li>
                            <li>O(1) for push/pop/peek</li>
                            <li>Useful for many problems</li>
                            <li>Easy to implement</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚úó Disadvantages</h4>
                        <ul>
                            <li>Limited access pattern (LIFO)</li>
                            <li>Cannot access middle elements</li>
                            <li>Can overflow in fixed size</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>üí° Key Takeaways</h2>
                <div class="pros-cons">
                    <div class="pros">
                        <h4>Stack Principles:</h4>
                        <ul>
                            <li>LIFO = Last-In-First-Out (like a stack of plates)</li>
                            <li>All insertions/deletions happen at the TOP only</li>
                            <li>Push adds to top, Pop removes from top</li>
                            <li>Peek shows top element without removing</li>
                            <li>Time complexity is O(1) for all basic operations</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>Interview Tips:</h4>
                        <ul>
                            <li>Think of stacks when you see "undo/redo" problems</li>
                            <li>Use stacks for DFS (Depth First Search) on graphs</li>
                            <li>MinStack is a popular interview question - practice it!</li>
                            <li>Always check for empty stack before popping</li>
                            <li>Consider space-time tradeoffs (like MinStack using O(2n) space for O(1) get_min)</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>üéØ Practice Tips</h2>
                <ol>
                    <li><strong>Visualize:</strong> Draw or imagine stacks as vertical structures. Add elements on top, remove from top.</li>
                    <li><strong>Edge Cases:</strong> Always handle empty stack cases. Test pop() on empty stack.</li>
                    <li><strong>Alternative Implementations:</strong> Practice both array-based and linked list-based stacks.</li>
                    <li><strong>Monotonic Stack:</strong> Study monotonic stack pattern - used in many medium/hard problems.</li>
                    <li><strong>Common Patterns:</strong> Parentheses matching, expression evaluation, undo/redo functionality.</li>
                </ol>
            </div>

            <div class="section">
                <h2>üìö Real-World Applications</h2>
                <ul>
                    <li><strong>Browser History:</strong> Back button uses a stack of visited pages</li>
                    <li><strong>Undo/Redo:</strong> Text editors store actions in stacks</li>
                    <li><strong>Function Calls:</strong> CPU uses call stack for function execution</li>
                    <li><strong>Expression Evaluation:</strong> Parsing and evaluating mathematical expressions</li>
                    <li><strong>Backtracking:</strong> Solving puzzles like N-Queens, maze solving</li>
                    <li><strong>Depth-First Search:</strong> Traversing trees and graphs</li>
                    <li><strong>Compiler Design:</strong> Syntax checking and parsing</li>
                </ul>
            </div>

            <div class="section">
                <h2>üîó Related Topics</h2>
                <ul>
                    <li><a href="queues.html">Queues</a> - Similar but FIFO structure</li>
                    <li><a href="linked-lists.html">Linked Lists</a> - Alternative implementation</li>
                    <li><a href="arrays.html">Arrays</a> - Another implementation method</li>
                    <li><a href="../algorithms/recursion.html">Recursion</a> - Uses call stack internally</li>
                </ul>
            </div>
        </div>
    </main>

    <footer class="footer">
        <div class="footer-content">
            <p>&copy; 2026 DSA with Python. Designed for students learning Data Structures and Algorithms.</p>
            <p>Created with ‚ù§Ô∏è for the programming community</p>
        </div>
    </footer>

    <script src="../../js/script.js"></script>
</body>
</html>
