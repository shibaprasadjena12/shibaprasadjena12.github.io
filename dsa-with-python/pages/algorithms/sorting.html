<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithms - DSA with Python</title>
    <link rel="stylesheet" href="../../css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <div class="logo"><h1>üìö DSA with Python</h1></div>
            <ul class="nav-menu">
                <li><a href="../../index.html">Home</a></li>
                <li class="dropdown">
                    <a href="#">Data Structures</a>
                    <div class="dropdown-content">
                        <a href="../data-structures/arrays.html">Arrays</a>
                        <a href="../data-structures/linked-lists.html">Linked Lists</a>
                        <a href="../data-structures/stacks.html">Stacks</a>
                        <a href="../data-structures/queues.html">Queues</a>
                        <a href="../data-structures/trees.html">Trees</a>
                        <a href="../data-structures/graphs.html">Graphs</a>
                        <a href="../data-structures/heaps.html">Heaps</a>
                        <a href="../data-structures/hash-tables.html">Hash Tables</a>
                    </div>
                </li>
                <li class="dropdown">
                    <a href="#">Algorithms</a>
                    <div class="dropdown-content">
                        <a href="sorting.html" class="active">Sorting Algorithms</a>
                        <a href="searching.html">Searching Algorithms</a>
                        <a href="dynamic-programming.html">Dynamic Programming</a>
                        <a href="recursion.html">Recursion</a>
                        <a href="graph-algorithms.html">Graph Algorithms</a>
                        <a href="greedy.html">Greedy Algorithms</a>
                    </div>
                </li>
                <li><a href="../complexity-analysis.html">Complexity Analysis</a></li>
                <li><a href="../resources.html">Resources</a></li>
            </ul>
            <div class="hamburger"><span></span><span></span><span></span></div>
        </div>
    </nav>

    <main class="content">
        <div class="page-container">
            <div class="breadcrumb"><a href="../../index.html">Home</a> / Algorithms / Sorting</div>
            <div class="page-header">
                <h1>Sorting Algorithms</h1>
                <p>Algorithms to arrange elements in a specific order</p>
            </div>

            <div class="section">
                <h2>Overview</h2>
                <p>Sorting algorithms are fundamental in computer science. They arrange elements in a specific order (ascending or descending). The choice of algorithm depends on data size, distribution, and memory constraints.</p>
            </div>

            <div class="section">
                <h2>1. Bubble Sort</h2>
                <div class="code-block">
                    <pre><code class="language-python">def bubble_sort(arr):
    """
    Bubble Sort: Compare adjacent elements and swap.
    Time: O(n¬≤) | Space: O(1)
    """
    n = len(arr)
    for i in range(n):
        swapped = False
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        if not swapped:
            break
    return arr

# Test
print(bubble_sort([64, 34, 25, 12, 22, 11, 90]))
# Output: [11, 12, 22, 25, 34, 64, 90]</code></pre>
                </div>
            </div>

            <div class="section">
                <h2>2. Selection Sort</h2>
                <div class="code-block">
                    <pre><code class="language-python">def selection_sort(arr):
    """
    Selection Sort: Find min and place at beginning.
    Time: O(n¬≤) | Space: O(1)
    """
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr</code></pre>
                </div>
            </div>

            <div class="section">
                <h2>3. Insertion Sort</h2>
                <div class="code-block">
                    <pre><code class="language-python">def insertion_sort(arr):
    """
    Insertion Sort: Insert each element in sorted position.
    Time: O(n¬≤) worst, O(n) best | Space: O(1)
    """
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        
        arr[j + 1] = key
    return arr</code></pre>
                </div>
            </div>

            <div class="section">
                <h2>4. Merge Sort</h2>
                <div class="code-block">
                    <pre><code class="language-python">def merge_sort(arr):
    """
    Merge Sort: Divide and conquer approach.
    Time: O(n log n) | Space: O(n)
    """
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    return result</code></pre>
                </div>
            </div>

            <div class="section">
                <h2>5. Quick Sort</h2>
                <div class="code-block">
                    <pre><code class="language-python">def quick_sort(arr):
    """
    Quick Sort: Partition and sort approach.
    Time: O(n log n) average, O(n¬≤) worst | Space: O(log n)
    """
    if len(arr) <= 1:
        return arr
    
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    return quick_sort(left) + middle + quick_sort(right)

# In-place version
def quick_sort_inplace(arr, low=0, high=None):
    if high is None:
        high = len(arr) - 1
    
    if low < high:
        pi = partition(arr, low, high)
        quick_sort_inplace(arr, low, pi - 1)
        quick_sort_inplace(arr, pi + 1, high)
    
    return arr

def partition(arr, low, high):
    pivot = arr[high]
    i = low - 1
    
    for j in range(low, high):
        if arr[j] < pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1</code></pre>
                </div>
            </div>

            <div class="section">
                <h2>6. Heap Sort</h2>
                <div class="code-block">
                    <pre><code class="language-python">def heap_sort(arr):
    """
    Heap Sort: Build heap and extract min repeatedly.
    Time: O(n log n) | Space: O(1)
    """
    n = len(arr)
    
    # Build max heap
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
    
    # Extract elements from heap
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)
    
    return arr

def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    if left < n and arr[left] > arr[largest]:
        largest = left
    
    if right < n and arr[right] > arr[largest]:
        largest = right
    
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)</code></pre>
                </div>
            </div>

            <div class="section">
                <h2>Comparison Table</h2>
                <table style="width:100%; border-collapse: collapse; margin: 1.5rem 0;">
                    <tr style="background-color: #f3f4f6;">
                        <th style="padding: 1rem; border: 1px solid #e5e7eb; text-align: left;"><strong>Algorithm</strong></th>
                        <th style="padding: 1rem; border: 1px solid #e5e7eb; text-align: left;"><strong>Best Time</strong></th>
                        <th style="padding: 1rem; border: 1px solid #e5e7eb; text-align: left;"><strong>Average Time</strong></th>
                        <th style="padding: 1rem; border: 1px solid #e5e7eb; text-align: left;"><strong>Worst Time</strong></th>
                        <th style="padding: 1rem; border: 1px solid #e5e7eb; text-align: left;"><strong>Space</strong></th>
                    </tr>
                    <tr>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">Bubble Sort</td>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">O(n)</td>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">O(n¬≤)</td>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">O(n¬≤)</td>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">O(1)</td>
                    </tr>
                    <tr style="background-color: #f9fafb;">
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">Selection Sort</td>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">O(n¬≤)</td>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">O(n¬≤)</td>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">O(n¬≤)</td>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">O(1)</td>
                    </tr>
                    <tr>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">Insertion Sort</td>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">O(n)</td>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">O(n¬≤)</td>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">O(n¬≤)</td>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">O(1)</td>
                    </tr>
                    <tr style="background-color: #f9fafb;">
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">Merge Sort</td>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">O(n log n)</td>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">O(n log n)</td>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">O(n log n)</td>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">O(n)</td>
                    </tr>
                    <tr>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">Quick Sort</td>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">O(n log n)</td>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">O(n log n)</td>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">O(n¬≤)</td>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">O(log n)</td>
                    </tr>
                    <tr style="background-color: #f9fafb;">
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">Heap Sort</td>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">O(n log n)</td>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">O(n log n)</td>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">O(n log n)</td>
                        <td style="padding: 1rem; border: 1px solid #e5e7eb;">O(1)</td>
                    </tr>
                </table>
            </div>

            <div class="section">
                <h2>When to Use Each Algorithm</h2>
                <ul>
                    <li><strong>Small arrays:</strong> Insertion Sort or Bubble Sort</li>
                    <li><strong>Large arrays:</strong> Merge Sort or Quick Sort</li>
                    <li><strong>Nearly sorted:</strong> Insertion Sort or Bubble Sort</li>
                    <li><strong>Limited memory:</strong> Heap Sort</li>
                    <li><strong>Python built-in:</strong> Use sorted() or list.sort()</li>
                </ul>
            </div>

            <div class="section">
                <h2>üí° Key Concepts</h2>
                <div class="pros-cons">
                    <div class="pros">
                        <h4>Stability in Sorting:</h4>
                        <ul>
                            <li><strong>Stable:</strong> Preserves order of equal elements (Bubble, Insertion, Merge)</li>
                            <li><strong>Unstable:</strong> May reorder equal elements (Selection, Heap, Quick)</li>
                            <li><strong>Example:</strong> Sorting [(2, 'a'), (1, 'b'), (2, 'c')]</li>
                            <li>Stable result: [(1, 'b'), (2, 'a'), (2, 'c')]</li>
                            <li>Unstable may have: [(1, 'b'), (2, 'c'), (2, 'a')]</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>In-Place Sorting:</h4>
                        <ul>
                            <li><strong>In-Place:</strong> Uses O(1) extra space (Bubble, Selection, Insertion, Heap, Quick)</li>
                            <li><strong>Not In-Place:</strong> Uses O(n) extra space (Merge Sort)</li>
                            <li>In-place sorting is preferred when memory is limited</li>
                            <li>Merge Sort sacrifices space for guaranteed O(n log n)</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>üéØ Algorithm Selection Guide</h2>
                <div class="code-block">
                    <pre><code class="language-text">Choose Sorting Algorithm Based On:

SIZE:
‚îú‚îÄ n < 10:      Insertion Sort (simple, efficient for tiny)
‚îú‚îÄ 10 < n < 100: Insertion Sort or Selection Sort
‚îî‚îÄ n > 100:     Merge Sort, Quick Sort, or Heap Sort

CHARACTERISTICS:
‚îú‚îÄ Nearly sorted:    Insertion Sort O(n) best case
‚îú‚îÄ Reverse sorted:   Insertion Sort O(n¬≤) worst, Quick Sort bad pivot
‚îú‚îÄ Many duplicates:  3-Way Quick Sort or Counting Sort
‚îî‚îÄ Unknown data:     Merge Sort (guaranteed O(n log n))

CONSTRAINTS:
‚îú‚îÄ Memory limited:   Quick Sort (O(log n)) or Heap Sort (O(1))
‚îú‚îÄ Need stable:      Merge Sort or Tim Sort
‚îú‚îÄ Partially sorted: Insertion Sort
‚îî‚îÄ Real-time:        Avoid Quick Sort (O(n¬≤) worst)

PRACTICE:
‚îú‚îÄ Interviews:       Know Quick Sort & Merge Sort well
‚îú‚îÄ Coding:           Use built-in sorted() or .sort()
‚îî‚îÄ Theory:           Understand Big-O analysis</code></pre>
                </div>
            </div>

            <div class="section">
                <h2>üéì Learning Path</h2>
                <ol>
                    <li><strong>Start with:</strong> Bubble Sort, Selection Sort (understand basics)</li>
                    <li><strong>Then learn:</strong> Insertion Sort (best case analysis)</li>
                    <li><strong>Next:</strong> Merge Sort (divide-and-conquer strategy)</li>
                    <li><strong>Finally:</strong> Quick Sort (randomization & partitioning)</li>
                    <li><strong>Advanced:</strong> Heap Sort, Tim Sort, Counting Sort</li>
                </ol>
            </div>

            <div class="section">
                <h2>‚ö†Ô∏è Common Mistakes</h2>
                <ul>
                    <li>‚ùå Using Bubble Sort for large datasets - O(n¬≤) will be too slow</li>
                    <li>‚ùå Not considering stability when sorting objects with multiple fields</li>
                    <li>‚ùå Ignoring worst-case for Quick Sort - can be O(n¬≤) with bad pivots</li>
                    <li>‚ùå Forgetting that Merge Sort uses O(n) space</li>
                    <li>‚ùå Not using built-in sort() - usually better than your implementation</li>
                    <li>‚ùå Assuming all algorithms have same performance - they don't!</li>
                </ul>
            </div>

            <div class="section">
                <h2>üìö Real-World Applications</h2>
                <ul>
                    <li><strong>Databases:</strong> Indexing (B-trees, similar to Merge Sort)</li>
                    <li><strong>Search Engines:</strong> Ranking results (custom comparators)</li>
                    <li><strong>Graphics:</strong> Z-buffer sorting (depth sorting)</li>
                    <li><strong>Operating Systems:</strong> Process scheduling</li>
                    <li><strong>E-commerce:</strong> Product sorting by price/rating</li>
                    <li><strong>Python's TimSort:</strong> Hybrid of Merge + Insertion (best of both worlds)</li>
                </ul>
            </div>

            <div class="section">
                <h2>üíª Built-in Python Sorting</h2>
                <div class="code-block">
                    <pre><code class="language-python"># Python uses TimSort - O(n log n), stable, efficient
arr = [3, 1, 4, 1, 5, 9, 2, 6]

# In-place sorting (modifies original)
arr.sort()
print(arr)  # [1, 1, 2, 3, 4, 5, 6, 9]

# Create new sorted list (original unchanged)
new_arr = sorted(arr)

# Sort in reverse
arr.sort(reverse=True)

# Sort by key (custom comparator)
people = [('Alice', 25), ('Bob', 20), ('Charlie', 30)]
people.sort(key=lambda x: x[1])  # Sort by age

# Sort with multiple criteria
people.sort(key=lambda x: (x[1], x[0]))  # Age first, then name</code></pre>
                </div>
            </div>

            <div class="section">
                <h2>üîó Related Topics</h2>
                <ul>
                    <li><a href="searching.html">Searching Algorithms</a> - Works with sorted data</li>
                    <li><a href="../complexity-analysis.html">Complexity Analysis</a> - Understand performance</li>
                    <li><a href="../data-structures/heaps.html">Heaps</a> - Used in Heap Sort</li>
                </ul>
            </div>
        </div>
    </main>

    <footer class="footer">
        <div class="footer-content">
            <p>&copy; 2026 DSA with Python. Designed for students learning Data Structures and Algorithms.</p>
            <p>Created with ‚ù§Ô∏è for the programming community</p>
        </div>
    </footer>

    <script src="../../js/script.js"></script>
</body>
</html>
